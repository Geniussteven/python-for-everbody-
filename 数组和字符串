#集合
1。元素类型不一定相同
2。无序
#列表
1。有一定的顺序，长度可变。
2。include数组.链表（常见）栈队列
#数组
C++/JAVA里需要元素类型保持一致。python不同
#difference between the 数组 列表
1。数组用索引数字标示数据位置
2。数组元素连续存储列表不同，数组元素占用相同大小内存。

#数组操作
1。读取元素
访问索引方式读取，对于数组，内存里有一段连续空间，记下索引为0的地址（分配一个内存地址）以此类推+索引值=目标元素地址
时间复杂度o（1）级因为知道内存地址
2。查找元素
从索引为0处从前往后查
时间复杂度o（N） N为数组长度
3。插入元素
末尾插入简单，插入中间链表更佳
4。删除元素
删除元素，空缺由后面元素填补
最坏情况下需要1+n-1步
时间复杂度o（N） N为数组长度
#寻找数组的中心索引
给你一个整数数组 nums ，请计算数组的 中心下标 。
数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。
如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。
如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。
例子-输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
#搜索插入位置
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
请必须使用时间复杂度为 O(log n) 的算法。
例子-输入: nums = [1,3,5,6], target = 2
输出: 1
#注意
提示:1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums 为无重复元素的升序排列数组
-104 <= target <= 104
#合并区间
以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
