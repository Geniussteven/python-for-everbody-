'''13.1 data om the web
API-application program interfaces
我们在网络上以某种形式传输数据，线路格式：XML、JSON
例如从python的dictionary里serialize(序列化)出一种交换格式，然后De-Serialize反序列化到Java Hashmap
'''
eXtensible Markup Language (XML)一种wire format
在start and end 之间的是text content ，start nodes之后的是atribute,是一种key-value pairs./>是self-closing tag
属性（Attribute）提供有关元素的额外信息,属性通常提供不属于数据组成部分的信息。在下面的实例中，文件类型与数据无关，但是对需要处理这个元素的软件来说却很重要：
<file type="gif">computer.gif</file>

关于XML与HTML的关键之处在于，我们可以编造标签。在HTML中，我们说像h1或a这样的锚标签，或h1代表头一级。在这里，基于我们要在两个交换数据的应用程序之间达成一致，你可以说标签是person和/person。
从一台计算机上的内部表示到一种交换格式的行为被称为序列化serialization
自我封闭的标签。就是说，你只要在开放标签的末尾包括这个/>。这就像你有一个同名的关闭标签，并有一个空的文本区域.

'''XML schema架构为了确认导致blow up的责任方，需要签订contract
Validation is the act of verifying that the data is in the right format. It's a contract. 
So if you're working with something like your airline reservation system that's working with an airline system
XML validation is the act of taking an document and a Schema Contract, which itself is also an XML document, and then sending to the Validator. 
'''
'''the XML Schema from the World Wide Web Consortium. It's called XSD and usually in the file that you get
maxOccurs 最多发生几次
'''
'''XSD Data types,普遍使用utc时间或者是格林威治时间
'''
#从XML里提取信息的方法
第一种针对无嵌套结构XML
import lib
然后输入xml
tree = ET.fromstring(data) 主要是转化为list of tree ,然后再从树里获取信息。
print（'name:', tree.find('name').text'）
print（'attr', tree.find('name').get(hide)'）
第二种针对嵌套结构XML
stuff = ET.fromstring(data)
ist = stuff.findall('users/user')
'''调用 findall 方法。我们将搜索用户下面的所有用户标签。在用户下有很多这些用户标签。把它们都找出来，然后把它们都给我。
所以你基本上得到的是这些标签以一个tree的列表展现。'''
print（'user count:', len(1st)）#看这个list有多长
for item in 1st:
  print（'name:', tree.find('name').text'）
  print（'attr', item.get("x")）
  
